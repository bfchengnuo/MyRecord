# 关于红黑树

> 原文地址：[程序员小灰](http://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&mid=2653191832&idx=1&sn=12017161025495c6914b5ab9397baa59&chksm=8c990c42bbee8554ba02eb83d839123bd3bead6ffc736111456ea77367a3df75750cf88016e0&mpshare=1&scene=1&srcid=0324ntTyrMjk4rn1BUApllAX#rd)

要学习红黑树首先要了解二叉查找树：

二叉查找树（BST）具备什么特性呢？

1. **左**子树上所有结点的值均**小于或等于**它的根结点的值。
2. **右**子树上所有结点的值均**大于或等于**它的根结点的值。
3. 左、右子树也分别为二叉排序树。

下图中这棵树，就是一颗典型的二叉查找树：

![](../img/RedBlackTree/二叉查找树.jpg)

这样的数据结构有什么好处呢？

我们试着查询一下值为 10 的节点：

1. 查看根节点 9

   ![](../img/redblacktree/gc1.jpg)

2. 由于**10 > 9**，因此查看右孩子**13**：

   ![](../img/redblacktree/gc2.jpg)

3. 由于**10 < 13**，因此查看左孩子**11**：

   ![](../img/redblacktree/gc3.jpg)

4. 由于**10 < 11**，因此查看左孩子**10**，发现10正是要查找的节点：

   ![](../img/redblacktree/gc4.jpg)

这种方式正是二分查找的思想，查找所需的最大次数等同于二叉树的高度。

在插入节点的时候也是利用类似的方法，通过一层层的比较大小，找到新节点适合插入的位置。

但是这种结构仍然有它的缺陷，体现在插入新节点上：

假设初始的二叉查找树只有三个节点，根节点值为9，左孩子值为8，右孩子值为12：

![](../img/redblacktree/gc5.jpg)

接下来我们依次插入如下五个节点：7,6,5,4,3。依照二叉查找树的特性，结果会变成什么样呢？



![](../img/redblacktree/gc6.jpg)

好好的二叉树变成了瘸子.....

正是如此，这样的形态虽然也符合二叉查找树的特性，但是查找性能大打折扣了；几乎变成了线性。

如何解决二叉查找树多次插入新节点而导致的不平衡问题呢？

【红黑树】应运而生！

> 红黑树（Red Black Tree）是一种自平衡的二叉查找树，除了符合二叉查找树的基本特性外，它还有下面几个附加特性：
>
> 1. 节点是红色或黑色。
> 2. 根节点是黑色。
> 3. 每个叶子节点都是黑色的空节点（NIL节点）。
> 4. 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)
> 5. 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。

下面的这棵树就是典型的红黑树：

![](../img/redblacktree/gc7.jpg)

正因为这些条件的限制，才保证了红黑树的自平衡性，**红黑树从根节点到叶子的最长路径不会超过最短路径的两倍。**

当插入或删除节点的时候，红黑树的规则可能会被打破，这时候就需要做出一些调整，来维持我们的规则。

什么情况下会破坏红黑树的规则，什么情况下不会破坏规则呢？我们举两个简单的栗子：

1. 向原红黑树插入值为**14**的新节点：

   ![](../img/redblacktree/gc8.jpg)

   由于父节点15是黑色节点，因此这种情况并不会破坏红黑树的规则，无需做任何调整。

2. 向原红黑树插入值为**21**的新节点：

   ![](../img/redblacktree/gc9.jpg)

   由于父节点22是红色节点，因此这种情况打破了红黑树的规则4（每个红色节点的两个子节点都是黑色），必须进行调整，使之重新符合红黑树的规则。

那么我们需要做出怎样的调整才能保证一颗红黑树始终是红黑树呢？

调整有两种方法：变色和旋转；其中，旋转又分为两种形式，坐旋转和右旋转。

## 变色：

为了重新符合红黑树的规则，尝试把红色节点变为黑色，或者把黑色节点变为红色。

下图所表示的是红黑树的一部分，需要注意节点25并非根节点。因为节点21和节点22连续出现了红色，不符合规则4，所以把节点22从红色变成黑色：

![](../img/redblacktree/bs1.jpg)

但这样并不算完，因为凭空多出的黑色节点打破了规则5，所以发生连锁反应，需要继续把节点25从黑色变成红色：

![](../img/redblacktree/bs2.jpg)

此时仍然没有结束，因为节点25和节点27又形成了两个连续的红色节点，需要继续把节点27从红色变成黑色：

![](../img/redblacktree/bs3.jpg)

## 旋转

**左旋转：**

**逆时针**旋转红黑树的两个节点，使得父节点被自己的右孩子取代，而自己成为自己的左孩子。说起来很怪异，大家看下图：

![](../img/redblacktree/zxz.jpg)

图中，身为右孩子的Y取代了X的位置，而X变成了自己的左孩子。此为左旋转。

**右旋转：**

**顺时针**旋转红黑树的两个节点，使得父节点被自己的左孩子取代，而自己成为自己的右孩子。大家看下图：

![](../img/redblacktree/yxz.jpg)

图中，身为左孩子的Y取代了X的位置，而X变成了自己的右孩子。此为右旋转。

那么，什么时候用旋转什么时候用变色呢？

这个确实有点复杂，红黑树的插入和删除包含很多种情况，每一种情况都有不同的处理方式，这里举一个典型的例子，体会一下：

我们以刚才插入节点21的情况为例：

![](../img/redblacktree/lz1.jpg)

首先，我们需要做的是**变色**，把节点25及其下方的节点变色：

![img](../img/redblacktree/lz2.jpg)

此时节点17和节点25是连续的两个红色节点，那么把节点17变成黑色节点？恐怕不合适。这样一来不但打破了规则4，而且根据规则2（根节点是黑色），也不可能把节点13变成红色节点。

变色已无法解决问题，我们把节点13看做X，把节点17看做Y，像刚才的示意图那样进行**左旋转**：

![img](../img/redblacktree/lz3.jpg)

![img](../img/redblacktree/lz4.jpg)

![img](../img/redblacktree/lz5.jpg)

由于根节点必须是黑色节点，所以需要**变色**，变色结果如下：

![img](../img/redblacktree/lz6.jpg)

这样就结束了吗？并没有。因为其中两条路径(17 -> 8 -> 6 -> NIL)的黑色节点个数是4，其他路径的黑色节点个数是3，不符合规则5。

这时候我们需要把节点13看做X，节点8看做Y，像刚才的示意图那样进行**右旋转**：

![img](../img/redblacktree/lz7.jpg)

![img](../img/redblacktree/lz8.jpg)

![img](../img/redblacktree/lz9.jpg)

最后根据规则来进行**变色**：

![img](../img/redblacktree/lz10.jpg)

如此一来，我们的红黑树变得重新符合规则。这一个例子的调整过程比较复杂，经历了如下步骤：

变色 -> 左旋转 -> 变色 -> 右旋转 -> 变色

## 应用

红黑树的应用有很多，其中 JDK 集合类 TreeMap 和 TreeSet 底层就是使用的红黑树来实现的，在 Java8 中，连 HashMap 也用到了红黑树。

**几点说明：**

1. 关于红黑树自平衡的调整，插入和删除节点的时候都涉及到很多种Case，由于篇幅原因无法展开来一一列举，有兴趣的朋友可以参考维基百科，里面讲的非常清晰。
2. 漫画中红黑树调整过程的示例是一种比较复杂的情形，没太看明白的小伙伴也不必钻牛角尖，关键要懂得红黑树自平衡调整的主体思想。