# 编写高效的SQL语句

虽然我并不喜欢跟数据库打交道，但是这终究是绕不开的，也不能指望 DBA 给你调优，那边顶多是优化数据库本身的压力，写的是烂 SQL，再优化也没用，还是得自己写的别太烂。

现代数据库相比也确实更加智能了，例如可以自动地把用户输入的 SQL 语句改写为多个语义相同的形式并从中选取一个耗时最少的语句来执行；这是理想情况下，很多情况它是识别不出你写的『迷惑性』SQL 的，也不要说优化了，总之，还是从自身开始，别指望上层给你做优化，低版本怎么办呢？还是得自己尽量写好。

因为不同的数据库有不同的优化策略，甚至同一数据库的不同版本也有不同的优化策略，所以，为了通用性，尽量以通用的写法为主。

## 优化目标

所谓优化，就是降低 I/O 和 CPU 的消耗，I/O 好理解，查询数据必须要从硬盘读取到内存，然后处理后返回；写数据也如此，所以内存数据库 Redis 速度会如此快。

另一个消耗就是 CPU，像 order by， group by，distinct 等操作都是需要 CPU 对内存的数据进行处理。

## 正确使用SELECT

首先老生常谈的问题，查询的时候尽量不要使用 `*` 通配符，现代数据库一般也进行了优化，但是实际上来看，其实效率差不了多少，关键可能并不是为了速度而是为了可读性。

一般思路来说使用 * 来查询，数据库引擎会把所有的列加载到内存，显然主要是 I/O 的开销，列越多越慢。

大多数关系型数据库都是按照行（row）的方式存储，而数据存取操作都是以一个固定大小的 IO 单元（被称作 block 或者 page）为单位，一般为 4KB，8KB…… 大多数时候，每个 IO 单元中存储了多行，每行都是存储了该行的所有字段（lob 等特殊类型字段除外）。

所以，**我们是取一个字段还是多个字段，实际上数据库在表中需要访问的数据量其实是一样的。**

当然，也有例外情况，那就是我们的这个查询在索引中就可以完成，也就是说当只取 a，b 两个字段的时候，不需要回表，而 c 这个字段不在使用的索引中，需要回表取得其数据。在这样的情况下，二者的 IO 量会有较大差异。

字段的多少大多数时候并不会影响到 IO 量，但是当还存在 order by 操作的时候，select 子句中的字段多少会在很大程度上影响到排序效率。

> 所以出现使用 select * 比 select col 快的情况也是正常的，如例外情况所说，使用 col 方式可能会查询两次，第二次是回表操作，这种情况下，* 的直接全表扫描反而只有一次，速度反而快了，但还是尽量不要去用 *。
>
> 特殊情况，查询 count 的时候，使用 * 基本都会有单独的优化，很多人喜欢使用 select count(1)，其实效率很差，结果来看推荐使用 * 或者主键。本质上 1 与 * 效果一样，但是 * 毕竟是专门优化的；
> 并且 1 不是表示的第一列，而是一个固定值，即每一行都返回 1，然后计算多少个 1，其他数值也是一样（在 MySQL 中你直接运行 `SELECT COUNT(1)` 的结果就是每一行的结果了）；
> count * 会把 null 行统计进去，col 不会，但是性能方面有较大差距。
> 特殊的存储引擎，例如 myIsam 直接默认存储行数，不需要扫描表。

尽量避免在列上使用函数，这会导致索引失效，例如：

``` sql
-- 错误
YEAR(data) > 2020
-- 正确
data > '2020-12-31'

-- 错误
Function(Column_A)= ‘ constant ’
-- 正确
Column_A=Inverse_Function( ‘ constant ’ )
```

函数的使用也是比较消耗性能的，最好能在业务层做，让数据库只负责数据的查询。

---

使用 Where 条件等过滤的几点准则：

- 尽早过滤
  Where 条件中，越精确的条件（能够剔除大部分结果的条件）放前面。
- 尽量少的条件
- 计算压力转移到后台
  尽量不要使用 SQL 来处理逻辑，例如日期格式化， null 的判断还会导致索引失效，尽量在业务层做。
- 能用 GROUP BY 的就不用 DISTINCT
  使用 GROUP BY 去重比 DISTINCT 效率高。
- 不要判断 null，如果必要，请设置默认值

---

多表操作时，尽量避免使用复杂的连接，例如：`where T1.a = T2.b` ，数据库执行的时候会分析使用那种方式连接优化来达到最大的效率，同时应该尽量让比较的双方使用相同的数据类型，否则可能会放弃使用某些优化连接策略；同样也应该尽量使用 `=` 其他的逻辑运算可能也会放弃一部分优化。

但是如果其中涉及表达式计算，例如：`where T1.a = T2.b + 10` ，那么只能使用最基本的连接方式，不做任何优化处理。

虽然你可以增加一列来避免进行表达式运算，但是那样空间成本就增加了，复杂度也增加了，还是不可兼得。

其他注意：

- 尽量用 join 代替子查询
  MySQL 的子查询效率一直有问题，能少用还是少用
- 很多时候用 exists是一个好的选择（in 与 exists 效率在不同场景效率有高有低，但 not exists 比 not in 的效率高）
- 适当的冗余字段，该冗余字段的值一般不变或者很少变化的。
- 优先顺序：INNER JOIN、LEFT JOIN (RIGHT JOIN 用 LEFT JOIN 替代)、CROSS JOIN

---

通常情况下，SQL 语句中的 GROUP BY 子句会导致数据库不得不通过一个排序（SORT）操作来实现对数据的分组，而排序被认为是一个比较耗费 CPU 和内存的操作。实际上某些情况下，如果写法得当，当中的排序操作是可以避免的。

具体来说，在写 GROUP BY 子句的时候，应该考虑到数据库中已经存在的索引的情况。如果 GROUP BY 子句中所有的列恰好包括在某个索引的键（Key column）的范围之内而且是处于开始的位置，那么在写 GROUP BY 子句的时候，**就应该按照该索引上键的先后顺序来写 GROUP BY 子句**。

### 示例

下面是一些查询的实践：

``` sql
-- 用 Union ALL 代替 OR，但是一般还是 OR 用的多
SELECT * FROM test1 WHERE NAME = 'test1_1' OR NAME = 'test1_2';

SELECT * FROM test1 WHERE NAME = 'test1_1'
union all
SELECT * FROM test1 WHERE NAME = 'test1_2';

-- exists 替代 in
select num from a where num in (select num from b);
select num from a where exists (select 1 from b where num=a.num)

-- group by 替代 distinct
SELECT DISTINCT OrderID FROM Details WHERE UnitPrice > 10
SELECT OrderID FROM Details WHERE UnitPrice > 10 GROUP BY OrderID

-- 禁用 group by 的自动排序
SELECT a, COUNT(1) FROM table GROUP BY a ORDER BY NULL ;
```

能用 UNION ALL 就不要用 UNION，它们的区别就是 UNION ALL 不执行 SELECT DISTINCT 函数，这样就会减少很多不必要的资源。

## 正确使用索引

索引的优缺点不需要赘述，使用索引避免了对表本身的全盘扫描，只需要对索引锁定的部分数据读取，大大加快了 I/O 读取，如果需要的数据全在索引中，那直接不需要进行回表操作了，直接返回速度更快。

创建索引的准则：

- 在经常需要搜索的列上，可以加快搜索的速度。
- 在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度。
- 在经常需要根据范围进行搜索的列上创建索引，**因为索引已经排序，其指定的范围是连续的。**

- 在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间。

- 在经常使用在 WHERE 子句中的列上面创建索引，加快条件的判断速度。

不应该创建索引的的这些列具有下列特点：

- 对于那些在查询中很少使用列不应该创建索引。
  这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。

- 对于那些只有很少数据值的列也不应该增加索引。
  这是因为，由于这些列的取值很少，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。

- 当修改性能远远大于检索性能时，不应该创建索引。
  这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。

索引可用在 select 后，也可用于 on、where 后的条件中，使用索引需要注意下面的情况，否则可能会导致索引失效：

- 尽量避免在索引过的字符数据中，使用非打头字母搜索，`col like '%abc'`
- 不要在 where 子句中的 “=” **左边**进行函数、算术运算或其他表达式运算
- 在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。
- not in、not exist 、聚合函数，都无法应用索引，连续的数值，能用 between 就不要用 in 了。
- 应尽量避免在 where 子句中使用 != 或 <> 操作符
   MySQL 只有对以下操作符才使用索引：<，<=，=，>，>=，BETWEEN，IN，以及某些时候的 LIKE（不以通配符开头）。
- 应尽量避免在 where 子句中使用 or 来连接条件
  or 条件下，仅有 myIsam 引擎或者 or 中全部是索引的情况下才会使用索引。
- 如果在 where 子句中使用参数（@name），也会导致全表扫描

对于 MySQL，在查询时最多只能使用一个索引。因此，如果 WHERE 条件已经占用了索引，那么在排序中就不使用索引了，这将大大降低查询的速度，解决方案可以将使用到的字段设置复合索引，但是排序的字段不能出现在 where 中，否则查询又慢了。
如果它们使用的是同一个索引，那么也是可以的；
如果排序字段中一个 DESC，一个 ASC，即使有索引效果也不会好。

如何判断查询 SQL 是否使用了索引，可以在语句前面使用 explain 关键字，type 列如果是 all 那就是没有使用索引。

## 数据类型

尽量选择合适的类型，例如数字就别用字符存储。

char/nchar 为固定长度，如果某个字段中字符长度**已知固定**，使用 char/nchar 效率比 varchar/nvarchar 效率高。

## 知识补充

不能部分使用 DISTINCT，DISTINCT 关键字作用于所有的列，不仅仅是跟在其后的那一列。

Mysql 数据库名和表名在 Windows 中是大小写不敏感的，而在大多数类型的 Unix/Linux 系统中是大小写敏感的，可以手动通过配置文件来控制。

ORACLE 的解析器总是按照从右到左的顺序处理 FROM 子句中的表名，在 MySQL 的企业版里也是如此。

## 拓展阅读

https://www.infoq.cn/article/DGMlqL9x0maeHGRltOKT