---
title: 继承，覆盖，抽象类，和多态
date: 2016-4-20
tags: [Java]
categories: Java
---


## 一、继承

1. 继承的好处：让类与类之间产生了关系，提高了代码的复用型。

2. 在java中继承的特点：

   - java只支持单继承，不支持多继承。

     原因：会产生调用的不确定性。

   - java支持多层继承，这样在java中就出现了继承体系。


3. 如何快速的使用一个继承体系？

   查阅父类内容，创建子类对象使用。

   注意：父类属性被私有化，子类即使继承也不能使用。

4. 什么时候定义继承？

​	当事物之间存在所属关系的时候。

5. this关键字和super关键字

   This关键字：代表本类对象。
   这里准确的说应该指的调用方，也就是：谁调用的就指的是谁

   Super关键字：代表父类所属的空间。

## 二、覆盖

1、什么是覆盖？

>当子类继承父类时，子类中有和父类中一模一样的方法时，子类的方法会覆盖父类的方法。

2、覆盖的使用注意事项。

- 2.1、当父类中的方法名和子类的方法名一样，返回值不一样时，会编译报错。

- 2.2、当父类的方法和子类的方法一摸一样时，会出现覆盖。自己有就别找别人。

- 2.3、子类覆盖父类时，必须保证覆盖方法比被覆盖方法权限大。

- 2.4、静态只能覆盖静态，或只能被静态覆盖。

3、什么时候使用覆盖？


>子类需要复写父类的功能，用到子类自己的功能时。
>
>覆盖举例：描述旧手机和新手机的更新过程。

4、继承中子类的实例化过程。


>子类的所有构造函数中的第一行，默认有就是super()，用于调用父类的构造函数。**也就是所子类在初始化的过程中父类也会初始化。**
>
>结论：父类构造函数既可以给父类初始化，也可以给子类初始化。

5、为什么子类的构造函数都要去默认访问父类的构造函数呢？


>因为子类继承父类，可以访问父类中已有的一些属性。

6、继承的弊端

- 打破了函数的封装性，当子类的方法和父类一模一样时，会改写父类的内容。

 解决方法：用final修饰方法。

7、finale关键字的特点：

- 1、final是一个修饰符，既可以修饰类，又可以修饰方法，还可以修饰变量。

- 2、final修饰的类不可以被继承。当一个类中不想有子类的时候我们可以用final修饰。

- 3、final修饰的方法不可以被覆盖。

- 4、final修饰的变量是一个常量。

为了将固定的一些数据方便使用，给于一个容易阅读的名称。

一般为final修饰的变量名是用大写字母组成，如果有多个单词，用下划线隔开。

注意：

- 1、如果父类中手动定义了有参数的构造函数，那么子类的构造函数中必须得手动定义super      来访问父类的构造函数。

- 2、this和super调用构造函数只能定义构造函数的第一行，不能同时存在。

- 3、子父类中通常不会出同名的属性。父类中既然定义了num属性，子类其实就没有必要再定义属性了。


- 4、构造函数就是构造器。

## 三、抽象类 

当描述事物时，没有足够的信息对该事物进行描述，那么该描述对应的类就是抽象类。

抽象类的特点：

1.  抽象方法一定定义在抽象类中。
2.  抽象类和抽象方法必须用abstract关键字修饰。
3.  抽象类不可以被实例化。
4.  抽象类必须由其子类覆盖掉所有抽象方法后，其子类才能进行实例化。

细节问题：
1. 抽象类一定是个父类？

    是
2. 抽象类是否有构造函数？

    有，给子类提供初始化动作。
3. 抽象类中是否可以不定义抽象方法？

    可以，作用是为了不让类实例化。
4. 抽象关键字不能和哪些关键字共存？

    final，private，static
5. 一般类和抽象类有什么异同呢?

    相同之处：

    -   里面可以定义属性，行为，构造函数。

    不同之处：
    - 一般类不可以定义抽象函数，抽象类可以。
    - 一般类可以被实例化，抽象类不行。
    - 一般类可以被继承，也可以不被继承。
    - 抽象类一定要被继承，抽象方法由子类全部覆盖后才能实例化。

## 四、接口

接口：当一个抽象类中全都是抽象方法的时候，这时可以讲这个抽象类定义成接口。

接口定义格式：定义接口跟定义类一样，不过是用interface来定义。

接口中常见定义内容：

1.  常量。全局变量吗，有固定修饰符 public static final
2.  抽象方法。固定修饰符 public abstract

**接口中不存在变量，变量通常要初始化，接口中不存在构造函数。**


接口特点：

1.  接口用interface来定义。
2.  接口中的成员都有固定的修饰符。
3.  接口不能被实例化。
4.  几大口必须由其子类覆盖了所有的抽象方法，该子类才能实例化。
5.  接口中的成员都是public修饰的。

好处：
1. 接口可以被多实现，一个类可以实现多个接口。

    误区：抽象函数，也要遵从函数的基本定义格式，要明确结果，明确未知内容。只不过函数体由子类来完成。
2.  一个类在继承一个类的同时还可以实现多个接口。
3.  类与类之间是继承，而且是单继承。类与接口之间是实现，而且可以多实现。
4.  接口与接口之间是继承关系，而且可以多继承。

调用情况？接口的特点：
1.  接口是对外暴露的规则。
2.  接口的出现降低了耦合性。
3.  接口出现提高了扩展性。

示例：usb，硬盘；接口定义后：

一方在使用这个接口，另一方在实现这个接口。

**接口和抽象类的区别：**
1.  类是用来继承的，只能单继承。接口是用来实现的，可以多实现。
2.  类中可以定义非抽象内容，直接提供给子类使用。**接口中只能定义抽象方法，需要子类全部实现。**
3.  类存在着继承关系，是is a关系。接口的实现关系，是like a 关系。

接口使用的代码示例：学生中有抽烟的学生，抽烟不是基本功能，而是扩展功能。
``` java
class Student
{
  void study(){}
}

interface Somke
{
  void somking();
}

class SomkeStudent extends Student implements Somke
{
  public void somking(){}
}
```
没有抽象方法的抽象类：

当一个接口中有多个抽象方法时，我们只需要用到其中的一个方法。

那么就写一个没有抽象方法的抽象类，来实现接口(虽然可能是空方法)。

没有抽象方法的抽象类，可以方便创建对象，去指定覆盖的方法。

## 四、多态

多态性：在程序中的体现，**父类或者接口的引用指向自己的子类对象。**

描述：如果说动物，就可以是指的是猫，狗，猪。

好处：提高了代码的扩展性。

弊端：只能使用父类中的功能，不能使用子类特有功能。（覆盖）

比如猫可以抓老鼠，但动物不具备抓老鼠功能。

多态前提：

1.  必须存在着继承关系。
2.  通常要有覆盖操作。

多态转型：

注意：在转型过程中都是子类对象在做转换。

1.  向上转型。
2.  向下转型。（强制转型）。

好处：可以使用子类的特有功能。

弊端：如果类型转换错误，会出现运行异常。

**什么时候使用转型？**

向上转型：当需要对程序进行扩展，或者限定对象的方法操作时。

向下转型：当要使用子类特有内容时，转型时需要判断，否则容易出现问题。

多态类型判断：

`ClassCastException`类型转换异常。

向下转型前，要进行判断，否则容易发生异常。判断用**instanceof**来完成。

## 五、Object对象

概述：

Object：所有类的父类。

所有对象都具备的内容不断抽取，就出现了Object类。

Object对象存在的属性和方法，所有对象都存在。

Objcet中方法：

1. equals(Object obj多态)比较两个对象是否相等。

    比较地址。源代码。

    可以覆盖Object类中的equals方法建立自己的比较方法。
2. toString()返回对象的字符串表示。（建议所有子类都重写此方法）

    打印p ，p.toString。打印对象。

    为了让自定义的对象对应的字符串表现形式有意义。覆盖toString方法即可。    
3.  getClass():获取任意一个对象所属的字节码文件对象。为class类型的。
4. hashCode():返回该对象的哈希码。

    字节码文件类中方法：getName():打印出本类的类名。 native修饰符，调用本地。