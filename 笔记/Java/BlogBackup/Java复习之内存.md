---
title: Java复习之内存
date: 2016-09-25 12:01:49
tags: [Java,内存]
categories: Java
---
想要更深入的学习Android最终还是要回过来仔细看下java的相关知识才行啊，曾经学过的也忘的差不多了，根据笔记整理成博文以便查阅吧~

这个一个大系列啊~~

## 关于内存

JVM运行肯定会对内存进行操作的，这个过程不想太深入(因为太复杂了= =)但是也不能了解的太浅，知道一些知识后如果出现OOM之类的问题排查起来还是挺有用的。

### 内存的划分

说一些我感觉比较有用的，大体可分为下面五个部分，栈和堆是必须要搞清楚的

- 寄存器
- 本地方法区
- 方法区
- 栈内存
- 堆内存

下面放张有点关系的图：
![JVM运行时数据数据区](http://o6lgtfj7v.bkt.clouddn.com/java%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA.jpg)

### 寄存器

CPU中存储数据的，非常小，但是效率非常高，毕竟离CPU最近，现在的CPU都有一级缓存、二级缓存了甚至三级缓存，这里的大小导致了价格、性能的巨大差距，寄存器可谓寸土寸金，关于这个不多解释，想了解推荐关注[码农翻身]刘哥写的文章，深入浅出。

这里还是贴个传送地址：[CPU阿甘系列](http://chuansong.me/n/335121451109)

### 本地方法区

这里也不想多解释，因为不是特殊原因，一般是不用深入了解的(~~其实是因为太复杂了~~)

这里只需要知道，这个区域和系统有关，会调用系统提供的一些方法、接口(windows/Linux/Mac OSX/Unix都是不同的)，这里不太需要我们操心....

### 方法区

方法区也是被所有的线程共享的一块内存区域。**它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码(字节码文件)等数据。**

程序运行必然执行方法，方法都是加载到方法区中的，方法区中还有片区域是专门存放被static修饰的变量或对象，我们称为静态区，除方法外的类等其他数据也会加载到方法区，多以字节码的形式，不过对于类来说是用到的时候再进行装载(也许就是传说中的类装载器)，不过静态变量的话应该就是直接保存具体值到静态区了。

非静态区持有个this来确定自己的所属(既然只能对对象调用，得确定是那个对象吧？)，静态区中的方法所属就比较简单了就是类名。

*[个人理解]方法区中加载的是类、方法等的字节码文件，简单说就是代码.....而开辟空间来存储变量或对象最终还是要到堆栈中(运行区)，所以下一步就是主函数进栈之类的啦....再说如果new很多个相同了类，只需要一份字节码文件即可，就是方法区中存一份即可*

JVM对这个区域的限制比较宽松，所以GC回收效果不是很好，甚至可以选择不进行GC回收，过于深入的这里就不探究了。

### 栈内存

![](http://img.blog.csdn.net/20150508103631436)
存储的都是局部变量（定义在函数里的变量），像print之类的是不进栈滴，会调用方法区执行了(大概...)

**作用一旦结束马上释放**

**先进**栈**后出**栈，**后进**栈**先出**栈

**不可以被多个线程共享，但速度快**

这里再补充下关于基本数据类型参数的传递：

```java
class Demo 
{
  int a; 	//成员变量，存在堆中，因为是对象中的变量嘛
  static int b;	//静态变量，存在方法区中
  public static void main(String[] args) 
  {
    int x = 3;
    show(x);
    System.out.println("x="+x);
  }
  public static void show(int x)
  {
    x = 4;
  }
}
```

很明显打印结果是3，它们两个方法都是在栈内存中，拥有自己的内存区域互不干扰，要实现main中的x = 4只能用return的方式来实现。

### 堆内存

存储数组和对象（**数组就是对象**）凡是用new建立的，也可以说为实体(多个数据的集合，实体作用就是封装数据)

每一个变量**都会有默认值**，**会进行初始化**

整数是0，小数是0.0或者0.0f，布尔变量是false，char类型是 `'\u0000' `，string(引用数据类型) 默认null

二维数组的初始化中，二维的那个数组默认值就是null啦(引用数据类型可以简单理解为不存具体数值存存地址的)，二维数组的值也是存的内存地址，引用数据类型

Java堆是垃圾回收器管理的主要区域，因此也被称为"GC堆"，java**允许堆处于不连续的内存空间中**，只要是逻辑上的连续即可，这一点很想硬盘的存储结构。

**可以被多个线程共享，速度慢，但灵活**

```java
int[] a = new int[3];
int[] b = new int[3];
```

上面的a和b可以理解成双胞胎，但觉不是同一个人，new就会在堆中产生一片空间，他们在内存中的地址是不同的

对象中的方法执行也是放在栈中的，但是会有个this关键字携带着本对象的指针(这里的指针代表地址)，以便于区分来自那个对象

### 垃圾回收机制

垃圾回收这其实是个程序，因为堆中并不会自动释放占用的内存，如果没人引用这个实体，那么这个实体就是个垃圾，垃圾就必须要回收，不然就会导致OOM，java的好处就是垃圾回收是自动进行的，不想C/C++要手动进行回收，当然GC回收垃圾的时机是随机的，堆中如果只有一个垃圾就回收那样怎么想都不合适，至于多少垃圾才回收这个就看GC的心情了...

当然也是可以进行手动进行调用GC来回收，但是就算手动调用也不一定马上进行回收。

### 内存泄漏和内存溢出

紧接着，知道了GC回收也应该了解下这方面的知识了，这也是在开发过程中常见的问题

- 内存泄露：指程序中一些对象不会被GC所回收，它始终占用内存，即**被分配的对象引用链可达但已无用**。（可用内存减少）
- 内存溢出：程序运行过程中**无法申请到足够的内存**而导致的一种错误。内存溢出通常发生于OLD段或Perm段垃圾回收后，仍然无内存空间容纳新的Java对象的情况。通俗说就是内存不够了！

内存泄露是内存溢出的一种诱因，不是唯一因素。

关于Android方面的OOM问题可以看我博客的一篇文章：[使用Application应该注意的事](http://bfchengnuo.info/2016/06/09/Android%E4%B8%AD%E7%9A%84Application%E7%B1%BB/#MemoryLeak-内存泄漏)

### 补充

#### **代码块的作用**

- 局部代码块：对于小程序来说，也许没啥用，也用不着加，对于较为庞大的程序还是蛮重要的，最大的一个功能就在于**限制生命周期**，如果方法、变量很多的话，写后面的时候鬼知道这个变量/方法有没有定义过呢....

  这里也是利用了栈内存的特点，用完就释放！


- 静态代码块：**对静态属性进行初始化**，随着类的加载(不是new)而加载执行，而静态方法还需要被调用才执行
- 同步代码块：**对线程进行保护**
- 构造代码块：和对象有关，每次new都会执行，但是执行静态方法不会执行构造代码块，**可以给所有对象初始化，运行在构造函数前**

执行顺序：静态代码块---->构造代码块----->局部代码块

```java
//局部代码块
public void show(){
  //省略代码
  {
    int a = 1,b = 2;
    add(a,b);
    ....
  }
}
//静态代码块
static{
  int a = 1;
  abs(a);
  ...
}
//同步代码块
synchronized{
  //耗时操作，放在线程 
}
//构造代码块  直接在类中定义
{
  //省略代码
}
```

## 参考

http://www.jianshu.com/p/7ebbe102c1ae