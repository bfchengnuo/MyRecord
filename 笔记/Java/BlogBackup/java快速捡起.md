---
title: Java快速捡起
date: 2017-01-02 15:03:38
tags: Java
categories: Java
---

长时间不写java都快忘光啦，赶紧把关键的一些东西捡起来，不过java的内容确实太多了，没办法先捡一部分最常用的，不断更新下吧....

可不可以不要忘的这么快，我还年轻....

也不知道那些懂好多技术/语言的大牛是怎么学的....

## 关于重载

首先我们知道要想**重载方法名是必须要相同的**，参数列表的个数如果相同那就类型不要相同，**只有**返回值不同的不叫重载，编译也会报错，JVM不知道应该返回那一个

也就是说，是不是重载主要看：

-   方法名是否相同
-   参数是否有变化(可以是数量上，也可以是类型上)

满足上面两点后至于返回值是什么就无所谓了

## 关于构造函数

关键点：

-   构造函数**没有**返回值，不是void，是没有
-   必须与类名相同
-   new的时候执行，优先级较高，主要作用是完成对象的初始化
-   **构造函数不能被继承**，因此它不能被覆盖
- **子类**可以通过super关键字来**显式调用**父类的构造函数，**当父类没有提供无参数的构造函数时，子类的构造函数中必须显示地调用父类的构造函数。**如果父类提供了无参数的构造函数，此时子类的构造函数就可以不显式地调用父类的构造函数，在这种情况下**编译器会默认调用父类提供的无参构造函数**。

    当有父类时，在实例化对象时会**先执行性父类的构造函数**，然后执行子类的构造函数
-   子类如果要显式调用父类的构造方法，必须写在子类构造方法的第一行
-   当父类和子类都没有定义构造函数时，编译器会为父类生成一个默认的无参构造函数，给子类也生成一个无参构造函数。
-   默认构造器的修饰符只跟当前类的修饰符有关(例如，如果一个类被定义为public，那么它的构造函数也是public)，所以修饰符是可以省略的

所以嘛，无论如何new的时候构造函数总会执行的，继承中父类的构造函数也总会执行的

稍微提一下匿名内部类，这个要说的话要写很长一段，简单说类似下面的这种形式：

```java
Father f1 = new Father(){ .... }
```

匿名内部类指的就是Father的内部类，但是没名字，也就没构造方法，一般是要实现未实现的方法或者重写方法，匿名内部类因为没名字也就只能用一次咯

> 这里需要注意，构造函数中的 this ，不一定指的是本对象
>
> 因为 this 指的是调用方，也就是谁调用指的就是谁
>
> 比如说，A 继承自 B，当在 new 一个 A 的时候，B 中的构造函数中的 this 指的就是 A 对象，因为是 A(孩子) 来调用 B(父亲) 的构造函数的
>
> 如果不太理解就先看看下面 **关于继承** 的最后

## 关于继承

比较重要的就是java是不支持多继承的，但是可以多重继承，额，就是A继承B，B继承C，那么A也相当于间接的继承了C，关于继承的其他特点：

-   子类拥有父类**非private的**属性，方法
-   子类可以拥有自己特有的属性和方法
-   子类可以用自己的方式实现父类的方法，也就是重写，覆盖

关于覆盖父类方法时需要注意一点：

-   覆盖方法的返回类型、方法名称、参数列表必须与原方法的相同。
-   覆盖方法不能比原方法访问性差（即访问权限不允许缩小）。
-   覆盖方法不能比原方法抛出更多的异常。
-   **被覆盖的方法不能是final类型**，因为final修饰的方法是无法覆盖的。
-   **被覆盖的方法不能为private**，否则在其子类中只是新定义了一个方法，并没有对其进行覆盖。话说private的方法本来子类中也是不可以访问的
- **被覆盖的方法不能为static**。如果父类中的方法为静态的，而子类中的方法不是静态的，但是两个方法除了这一点外其他都满足覆盖条件，那么会发生编译错误；反之亦然。

    即使父类和子类中的方法都是静态的，并且满足覆盖条件，但是仍然不会发生覆盖，因为静态方法是在编译的时候把静态方法和类的引用类型进行匹配。但是父类的静态方法会被隐藏
-   属性只能被隐藏不能被覆盖

子类是可以调用父类的静态方法或者属性的，他们其实是同一个变量(可以看看关于内存相关的介绍)，但是不会被覆盖，只会被隐藏

当子类重新定义了父类静态属性则子类的静态属性与父类的静态属性是两个不同的变量

静态方法调用的是定义这个静态方法的类的静态属性。

>   隐藏和覆盖的区别：
>
>   被隐藏的属性，在子类被强制转换成父类后，访问的是父类中的属性
>
>   被覆盖的方法，在子类被强制转换成父类后，调用的还是子类自身的方法
>
>   引用自：http://www.cnblogs.com/xiaoQLu/archive/2013/01/07/2849869.html

更新补充：

Java子类对象里总有一个父类对象，对就是对象！！！ 所以用super可以引用之

在`new Child()`的时候，实际上是先new了一个Father的对象，会自动先`this.super = new Father()`

可以看得出，虽然是父类对象，但是它存在于子类的内存空间中

以上说法有些人持不同意见的，我表示比较赞同

## 关于多态

这里只说下我比较容易翻车的地方吧

```java
class A {
	public void method(){
		System.out.print ("A method");
	}
	public void methodB(){
		System.out.print ("fufufu");
	}
}

class B extends A{	
	public void methodB(){
		System.out.print ("Child methodB");
	}
}

class Test {
	public static void main(String[] args) {
		A b= new B();  //多态
		b.methodB();
	}
}
```

要想能够执行`b.methodB();`方法，在父类中一定要有这个方法，即使你是new的子类，但是定义的却是父类，所以要想编译器不报错父类中要有这个方法，相应的执行的是子类的方法，因为new的就是子类，是子类的实例

多态感觉在接口上使用的比较多，尤其是回调的时候

## 什么是封装

>   封装从字面上来理解就是包装的意思，专业点就是**信息隐藏**，是指利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体，**数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节**，只保留一些对外接口使之与外部发生联系。
>
>   系统的其他对象只能通过包裹在数据外面的已经授权的操作来与这个封装的对象进行交流和交互。也就是说用户是无需知道对象内部的细节（当然也无从知道），但可以通过该对象对外的提供的接口来访问该对象。
>
>   对于封装而言，一个对象它所封装的是自己的属性和方法，所以它是不需要依赖其他对象就可以完成自己的操作。
>
>   引用自：http://wiki.jikexueyuan.com/project/java-enhancement/java-one.html

我们就应该习惯于在对象中将属性声明成private的，然后提供get/set方法进行访问，比如可以在setter()方法中可以对输入的值进行合法性检测等，这样保护了数据的安全可靠

## 杂项

 强制类型转换时并不会进行四舍五入，是直接舍弃小数点后

```java
System.out.print ((int)2.5);
//输出为2
```

如果需要四舍五入需要自己实现，简便的方法就是转换前直接加个0.5，或者使用`Math.round()`方法

------

关于super这个关键字，可以理解为是一个对父类的引用，指的就是父类那个对象，一般有两种用法：

一是：调用父类构造方法

二是：调用父类的属性和一般方法

this也比较类似了，只不过指的是本类(对象)的引用，`XXX.this`的用法比较常见呢

------

接口是一种特殊的类，接口可以继承接口，类只能实现接口

接口的方法默认是**public abstract**

接口中不可以定义变量即定义的变量前都要加上final修饰，使之成为常量(没有final修饰的是变量，加上final修饰就会变成常量)。所以接口的属性默认是**public static final** 常量，且必须赋初值。

----

Java中，一个文件只能包含一个public类；声明为public的类 文件名与类名要相同

静态内部类无法使用外部类的**非静态**方法/变量，因为不含外部类的引用

类中的静态属性在内存中只存在一份，无论你new多少个实例，就是一个，改变则所有都改变

静态内部类可以被实例化，static修饰的类不是说它自己是静态类，而是说它是外部类的静态成员。大概也能解释通了为什么可以调用外部类的静态方法/变量

## 参考

https://www.cnblogs.com/chenssy/p/3388487.html

http://blog.csdn.net/zhang_yanye/article/details/50344447