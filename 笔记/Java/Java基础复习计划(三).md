# Java基础复习计划（三）

## 散碎知识点

- Math.round() 方法进行四舍五入计算，实现是：`Math.floor(a + 0.5f)`

  floor ： 意为地板，指向下取整，返回**不大于**它的最大整数

  ceil ： 意为天花板，指向上取整，返回**不小于**它的最小整数 

  round ： 意为大约，表示“四舍五入”，而四舍五入是往大数方向入.

- 关于方法区溢出：

  经常动态生成大量 Class 的应用中，Spring、hibernate 对类进行增强的时候使用 CGLib 类字节码技术 ，其他运行在 JVM 的动态语言；

  常见的还有大量 JSP 或动态产生 JSP 文件的应用（JSP 第一次运行时需要编译）

- `public Method[] getDeclaredMethods()` 返回类或接口声明的**所有方法**，包括 public, protected, default (package) 访问和 private 方法的 Method 对象，但**不包括继承的方法**。当然也包括它所实现接口的方法。

  `public Method[] getMethods()` 返回类的所有 public 方法，包括其继承类的公用方法，当然也包括它所实现接口的方法。

- 关于类加载器的简要分类：

  引导类加载器（bootstrap class loader）：它用来加载 Java 的核心库，是用原生代码来实现的。

  扩展类加载器（extensions class loader）：它用来加载 Java 的扩展库。

  系统类加载器（system class loader）：它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。

  tomcat 为每个 App 创建一个 Loader，里面保存着此 WebApp 的 ClassLoader。需要加载 WebApp 下的类时，就取出 ClassLoader 来使用。



## 线程

线程的五大状态：

1. 新生（Born）
2. 就绪（Runnable）
3. 运行（Running）
4. 消亡（Dead）
5. 阻塞（Blocking）

创建线程的方式：

1. extends Thread
2. implements Runnable

控制线程的几种常见方法：

- setPriority(int)
  设置线程的优先级，可选范围 1- 10，默认为 5，越大优先级越高；
  没什么意义，因为只是概率而已
- static sleep(long)
- join()
  **当前线程**邀请另一个线程优先执行，比如主线程里写 `xx.join();` 意思就是主线程让 xx 线程执行完成后再执行，否则一直处于阻塞状态。
- static yield()
  让**当前线程**放弃持有的时间片，直接回到就绪，当然也有可能出现放弃时间片后又被 Cpu 选中的情况。 
- setName() + getName()
- static activeCount()
  得到程序中所有活跃线程的总数，活跃线程：就绪 + 运行 + 阻塞；
  这个方法永远不可能返回 0，至少是 1.
- static currentThread()
  得到当前线程对象，比如获得主线程的对象，在 run 方法调用的其他方法中使用；
  在 run 方法中没必要，直接 this 就是了。
- setDaemon(true)
  设置成为守护进程，当程序中只剩下守护线程时会自动终结自己；
  Java 中著名的守护线程 GC，一般的特性：
  1. 通常是无限循环的
  2. 守护线程一般有极低的优先级
  3. 设置守护线程必须在 start 之前
- interrupt()
  中断线程的阻塞状态，比如 sleep 时间还没到可以用 interrupt() 强制唤醒，但是会抛出一个异常。

**线程中所有静态方法不关注谁调用的，而是关注出现在哪里，出现在哪里就是操作那个线程。**

**线程中所有涉及主动进入阻塞状态的方法都需要进行异常处理**

### 关于锁

锁的出现就是为了解决并发错误，当多个线程共享同一个对象的时候，某一个线程未处理完成时 CPU 时间片就用尽了，然后就会出现并发错误。

然后就需要加锁来保证不会出现错误，通常有两种方案：

- 使用 synchronized 关键字
  叫做互斥锁，或者互斥锁标记，它可以修饰方法或者代码块，用在代码块上要显式的声明锁，用在方法上默认是 this。
  还有就是 **synchronized 特性本身不会被继承**
- java.util.concurrent.locks.ReentrantLock
  可翻译为可重用锁，JDK1.5 加入的，遵循了 OO 思想，有两个方法：lock() 和 unlock()

锁如果使用不当就会形成死锁，要解决死锁一般需要用到 Object 的三个方法：

- wait()
  让当前线程放弃已持有的锁标记，并且进入调用方对象的等待池。
- notify()
  唤醒调用方对象中等待池中的某个线程，是随机的。
- notifyAll()
  唤醒调用方对象中等待池中的全部线程

这三个方法都必须在已经持有锁标记的前提下才能使用，**所以它们都必须出现在synchronized(){当中}**

### 锁池和等待池

利用每一个对象都有一个锁旗标，拥有这个旗标后才可以访问此对象的资源，当线程无法获取此对象的锁旗标时就会发生阻塞进入此对象的锁池，等待旗标的释放，当释放后所有的等待旗标的线程会被唤醒，进入就绪状态争夺旗标。

使用 wait 会进入等待池，遇到 synchrnized 会进入锁池；

进入等待池会释放当时持有的锁，而锁池不会；

锁池中，只要锁标记再度可用 线程自动离开，等待池 必须要 notify() 或者 notifyAll()；

关于离开的去向：离开锁池前往就绪；离开等待池前往锁池（之前释放了锁，必须得重新获取锁，既然有人唤醒它，说明此时旗标肯定在别人手里）

![](../../img/lock.png)

## 原码反码补码

对于一个数, 计算机要使用一定的编码方式进行存储. 原码, 反码, 补码是机器存储一个具体数字的编码方式.

原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值，原码是人脑最容易理解和计算的表示方式。

  ```
[+1]原 = 0000 0001

[-1]原 = 1000 0001
  ```

正数的反码是其本身；负数的反码是在其原码的基础上, 符号位不变，其余各个位取反.

  ``` 
[+1] = [00000001]原 = [00000001]反

[-1] = [10000001]原 = [11111110]反
  ```

正数的补码就是其本身；负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1)

  ``` 
[+1] = [00000001]原 = [00000001]反 = [00000001]补

[-1] = [10000001]原 = [11111110]反 = [11111111]补
  ```
那么为何要使用原码, 反码和补码？

首先， 因为人脑可以知道第一位是符号位， 在计算的时候我们会根据符号位， 选择对真值区域（可理解为不加符号位的二进制表示）的加减。

但是对于计算机，加减乘数已经是最基础的运算，要设计的尽量简单； 计算机辨别 "符号位" 显然会让计算机的基础电路设计变得十分复杂!

于是人们想出了将符号位也参与运算的方法； 我们知道, 根据运算法则减去一个正数等于加上一个负数, 即:  1-1 = 1 + (-1) = 0 , 所以**机器可以只有加法而没有减法，这样计算机运算的设计就更简单了**.

于是人们开始探索 将符号位参与运算， 并且只保留加法的方法， 首先来看原码:

计算十进制的表达式: 1-1=0

> 1 - 1 = 1 + (-1) = [00000001]原 + [10000001]原 = [10000010]原 = -2

如果用原码表示， 让符号位也参与计算， 显然对于减法来说， 结果是不正确的；这也就是为何计算机内部不使用原码表示一个数.

为了解决原码做减法的问题， 出现了反码:

计算十进制的表达式: 1-1=0

> 1 - 1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原= [0000 0001]反 + [1111 1110]反 = [1111 1111]反 = [1000 0000]原 = -0

发现用反码计算减法， 结果的真值**部分是正确的**. 

而唯一的问题其实就出现在 "0" 这个特殊的数值上， 虽然人们理解上 +0 和 -0 是一样的，但是 0 带符号是没有任何意义的， 而且会有 [0000 0000]原 和 [1000 0000]原 两个编码表示 0.

**于是补码的出现， 解决了 0 的符号以及两个编码的问题**:

> 1-1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原 = [0000 0001]补 + [1111 1111]补 = [0000 0000]补=[0000 0000]原

这样 0 用 [0000 0000] 表示， 而以前出现问题的 -0 则不存在了；而且可以用 [1000 0000] 表示 -128:

> (-1) + (-127) = [1000 0001]原 + [1111 1111]原 = [1111 1111]补 + [1000 0001]补 = [1000 0000]补

-1-127 的结果应该是 -128， 在用补码运算的结果中  [1000 0000]补 就是 -128， 但是注意因为实际上是使用以前的 -0 的补码来表示 -128， 所以 -128 并**没有原码和反码表示**（所以可以多表示一个最低数）.(对 -128 的补码表示 [1000 0000]补 算出来的原码是 [0000 0000]原, 这是不正确的)

使用补码, 不仅仅修复了 0 的符号以及存在两个编码的问题， 而且还能够多表示一个最低数； 这就是为什么 8 位二进制， 使用原码或反码表示的范围为 [-127, +127]， 而使用补码表示的范围为 [-128, 127].

因为机器使用补码, 所以对于编程中常用到的 32 位 int 类型，可以表示范围是: [-231, 231-1] 因为第一位表示的是符号位.而使用补码表示时又可以多保存一个最小值.

出自：https://www.cnblogs.com/zhangziqiu/archive/2011/03/30/ComputerCode.html