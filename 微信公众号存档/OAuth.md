# OAuth

## 什么是OAuth

>   OAuth（开放授权）是一个开放标准，允许用户让第三方应用访问该用户在某一网站上存储的私密的资源（如照片，视频，联系人列表），而无需将用户名和密码提供给第三方应用。
>
>   **OAuth 允许用户提供一个令牌，而不是用户名和密码来访问他们存放在特定服务提供者的数据。**每一个令牌授权**一个**特定的网站（例如，视频编辑网站)在特定的时段（例如，接下来的2小时内）内访问特定的资源（例如仅仅是某一相册中的视频）。
>
>   这样，OAuth 让用户可以授权第三方网站访问他们存储在另外服务提供者的某些特定信息，而非所有内容。
>
>   OAuth 是OpenID的一个补充，但是完全不同的服务
>
>   OAuth 开始于2006年11月，当时布莱恩·库克正在开发 Twitter 的 OpenID 实现。

说一句，目前 OAuth 的版本是 2.0

【图片与相关连接丢失.....，看公众号的原文吧】

## 应用场景

广泛应用的其实是 第三方登陆 功能

假设我们可以使用 Google 登录 pixiv ，pixiv 会自动将你的 Google 头像设置为你的 pixiv 头像，将你的 Google 昵称设置为你的 pixiv 昵称，甚至还可以获取你 Google 中的好友列表，提示你哪些朋友已经在使用 pixiv

传统方式就是让你输入账号密码，然后第三方再利你提交的账号信息进行获取信息，但是这样会非常的不安全，它有了你账号的完全控制权，可能会搞点破坏之类的

这时候就用到 OAuth 了！

## 运行流程

OAuth 2.0的运行流程如下图，摘自RFC 6749

>   （A）用户打开客户端以后，客户端要求用户给予授权。
>   （B）用户同意给予客户端授权。
>   （C）客户端使用上一步获得的授权，向认证服务器申请令牌。
>   （D）认证服务器对客户端进行认证以后，确认无误，同意发放令牌。
>   （E）客户端使用令牌，向资源服务器申请获取资源。
>   （F）资源服务器确认令牌无误，同意向客户端开放资源。

来一张中文版的图吧

## 客户端的授权模式

从上面的图也看得出，客户端必须得到用户的授权（authorization grant），返回一个 Code，然后通过这个 Code 才能获得令牌（access token）。OAuth 2.0定义了四种授权方式。

-   授权码模式（authorization code）
-   简化模式（implicit）
-   密码模式（resource owner password credentials）
-   客户端模式（client credentials）

### 授权码模式

授权码模式（authorization code）是功能最完整、流程最严密的授权模式。它的特点就是通过客户端的后台服务器，与"服务提供商"的认证服务器进行互动。

>   （A）用户访问客户端，后者将前者导向认证服务器。
>   （B）用户选择是否给予客户端授权。
>   （C）假设用户给予授权，认证服务器将用户导向**客户端事先指定的"重定向URI"**（redirection URI），同时附上一个授权码。
>   （D）客户端收到授权码，附上早先的"重定向URI"，向认证服务器申请令牌。这一步是在客户端的后台的服务器上完成的，对用户不可见。
>   （E）认证服务器核对了授权码和重定向URI，确认无误后，向客户端发送访问令牌（access token）和更新令牌（refresh token）。

注意：
C 步骤中，授权码的的有效期应该很短，通常设为 10 分钟，客户端**只能使用该码一次**，否则会被授权服务器拒绝。**该码与客户端 ID 和重定向 URI，是一一对应关系。**

### 简化模式

简化模式（implicit grant type）不通过第三方应用程序的服务器，直接在浏览器中向认证服务器申请令牌，跳过了"授权码"这个步骤，因此得名。所有步骤在浏览器中完成，令牌对访问者是可见的，且客户端不需要认证。

>   （A）客户端将用户导向认证服务器。
>   （B）用户决定是否给于客户端授权。
>   （C）假设用户给予授权，认证服务器将用户导向客户端指定的"重定向URI"，并在URI的Hash部分包含了访问令牌。
>   （D）浏览器向资源服务器发出请求，其中不包括上一步收到的Hash值。
>   （E）资源服务器返回一个网页，其中包含的代码可以获取Hash值中的令牌。
>   （F）浏览器执行上一步获得的脚本，提取出令牌。
>   （G）浏览器将令牌发给客户端。

### 密码模式

密码模式（Resource Owner Password Credentials Grant）中，用户向客户端提供自己的用户名和密码。客户端使用这些信息，向"服务商提供商"索要授权。

在这种模式中，用户必须把自己的密码给客户端，但是客户端不得储存密码。这通常用在用户对客户端高度信任的情况下，比如客户端是操作系统的一部分，或者由一个著名公司出品。而认证服务器只有在其他授权模式无法执行的情况下，才能考虑使用这种模式。

>   （A）用户向客户端提供用户名和密码。
>   （B）客户端将用户名和密码发给认证服务器，向后者请求令牌。
>   （C）认证服务器确认无误后，向客户端提供访问令牌。

### 客户端模式

客户端模式（Client Credentials Grant）指客户端以自己的名义，而不是以用户的名义，向"服务提供商"进行认证。严格地说，客户端模式并不属于OAuth框架所要解决的问题。在这种模式中，用户直接向客户端注册，客户端以自己的名义要求"服务提供商"提供服务，其实不存在授权问题。

>   （A）客户端向认证服务器进行身份认证，并要求一个访问令牌。
>   （B）认证服务器确认无误后，向客户端提供访问令牌。

认证服务器必须以某种方式，验证客户端身份。

## 更新令牌

刚开始的时候就说过，令牌是在指定的时间内才有效的，如果用户访问的时候，客户端的"访问令牌"已经过期，则需要使用"更新令牌"申请一个新的访问令牌。

客户端发出更新令牌的 HTTP 请求，包含以下参数：

-   granttype：表示使用的授权模式，此处的值固定为“refreshtoken”，必选项。
-   refresh_token：表示早前收到的更新令牌，必选项。
-   scope：表示申请的授权范围，不可以超出上一次申请的范围，如果省略该参数，则表示与上一次一致。

PS:
在请求过程中，注意请求头的 Authorization 字段，它一般用于认证，携带认证信息，有时通过 Base64 解码能解出 `账号:密码` 的形式，这个我们以后单独再说

## 其他

> Bearer Token ([RFC 6750](http://www.rfcreader.com/#rfc6750)) 用于OAuth 2.0授权访问资源，任何Bearer持有者都可以无差别地用它来访问相关的资源，而无需证明持有加密key。一个Bearer代表授权范围、有效期，以及其他授权事项；一个Bearer在存储和传输过程中应当防止泄露，需实现Transport Layer Security (TLS)；一个Bearer有效期不能过长，过期后可用Refresh Token申请更新。

一般是通过请求头携带 Bearer token 的方式。