servlet 采用单实例多线程模式开发，减少产生 servlet 实例的开销。

**servlet容器维护一个线程池**，里面放着工作线程来响应请求，同时还有一个调度线程来管理工作者线程。

当容器收到一个servlet请求，调度线程就从线程池中取出一个工作者线程，该工作者线程将处理这个请求，做法是**执行servlet的service方法**；当这个线程执行时，收到另一个请求，调度线程就在线程池中取出另一个工作者线程来响应新的请求。

容器不关心请求是否访问的是同一个 servlet,当多个请求同时访问同一个 servlet 时，**这个 servlet 的 service 方法将在多线程中并发执行**。并发执行必然会**出现同步问题**，也就是线程的安全问题，下面是网上找到的原本版本。绕来绕去，总也绕不开几门基础课，终于明白为什么考研要考数据结构，操作系统，组成原理和网络原理了，这一个线程安全问题就涉及到数据结构和操作系统，数据结构帮助选择线程安全的数据类型，操作系统帮助找到线程安全的操作方法。

## Servlet容器如何同时来处理多个请求

- 工作者线程 Work Thread
  执行代码的一组线程

- 调度线程 Dispatcher Thread：
  每个线程都具有分配给它的线程优先级,线程是根据优先级调度执行的 

Servlet 采用多线程来处理多个请求同时访问。**servlet依赖于一个线程池来服务请求**。线程池实际上是一系列的工作者线程集合。

Servlet使用一个调度线程来管理工作者线程。当容器收到一个Servlet请求，调度线程从线程池中选出一个工作者线程,将请求传递给该工作者线程，**然后由该线程来执行Servlet的service方法**。

当这个线程正在执行的时候,容器收到另外一个请求,调度线程同样从线程池中选出另一个工作者线程来服务新的请求,容器并不关心这个请求是否访问的是同一个 Servlet 。当容器同时收到对同一个 Servlet 的多个请求的时候，那么这个 Servlet 的 service() 方法将在多线程中并发执行。

Servlet 容器默认采用单实例多线程的方式来处理请求，这样减少产生Servlet实例的开销，提升了对请求的响应时间，**对于 Tomcat 可以在 server.xml 中通过 `<Connector>` 元素设置线程池中线程的数目。**

就实现来说：

调度者线程类所担负的责任是线程的调度，只需要利用自己的属性完成自己的责任。所以该类是承担了责任的，并且该类的责任又集中到唯一的单体对象中。

而其他对象又依赖于该特定对象所承担的责任，我们就需要得到该特定对象。那该类就是一个单例模式的实现了。 
    

## 如何开发线程安全的Servlet

1. 变量的线程安全：这里的变量指字段和共享数据(如表单参数值)。 

  a) 将参数变量本地化。多线程并不共享局部变量.所以我们要尽可能的在servlet中使用局部变量。

  例如：`String user = ""; user = request.getParameter("user");`

  b) 使用同步块 Synchronized，防止可能异步调用的代码块。这意味着线程需要排队处理。

  在使用同步块的时候要尽可能的缩小同步代码的范围，不要直接在sevice方法和响应方法上使用同步，这样会严重影响性能。

2. 属性的线程安全：ServletContext，HttpSession，ServletRequest对象中属性

  ServletContext：（线程是不安全的）

  ServletContext 是可以多线程同时读/写属性的，线程是不安全的。要对属性的读写进行同步处理或者进行**深度Clone()**

  所以在Servlet上下文中尽可能少量保存会被修改（写）的数据，可以采取其他方式在多个Servlet中共享，比方我们可以使用单例模式来处理共享数据。 

  HttpSession：（线程是不安全的）

  HttpSession 对象在用户会话期间存在，只能在处理属于同一个 Session 的请求的线程中被访问，因此Session对象的属性访问理论上是线程安全的。

  当用户打开多个同属于一个进程的浏览器窗口，在这些窗口的访问属于同一个 Session，会出现多次请求，需要多个工作线程来处理请求，可能造成同时多线程读写属性。

  这时我们需要对属性的读写进行同步处理：使用同步块 Synchronized 和使用读/写器来解决。

  ServletRequest：（线程是安全的）

  对于每一个请求，由一个工作线程来执行，都会创建有一个新的 ServletRequest 对象，所以 ServletRequest 对象只能在一个线程中被访问。ServletRequest 是线程安全的。

  **注意：ServletRequest 对象在 service 方法的范围内是有效的，不要试图在 service 方法结束后仍然保存请求对象的引用。**

3. 使用同步的集合类

  使用 Vector 代替 ArrayList，使用 Hashtable 代替 HashMap

4. 不要在 Servlet 中创建自己的线程来完成某个功能。

  Servlet 本身就是多线程的，在 Servlet 中再创建线程，将导致执行情况复杂化，出现多线程安全问题。 

5. 在多个 servlet 中对外部对象(比方文件)进行修改操作一定要加锁，做到互斥的访问。

6. `javax.servlet.SingleThreadModel` 接口是一个标识接口，如果一个 Servlet 实现了这个接口，那 Servlet 容器将保证在一个时刻仅有一个线程可以在给定的 servlet 实例的 service 方法中执行。将其他所有请求进行排队。

  服务器可以使用多个实例来处理请求，代替单个实例的请求排队带来的效益问题。

  服务器创建一个 Servlet 类的多个 Servlet 实例组成的实例池，对于每个请求分配 Servlet 实例进行响应处理，之后放回到实例池中等待下此请求。这样就造成并发访问的问题。 

  此时，局部变量(字段)也是安全的，但对于全局变量和共享数据是不安全的，需要进行同步处理。而对于这样多实例的情况 SingleThreadModel 接口并不能解决并发访问问题。

> SingleThreadModel 接口在 servlet 规范中已经被废弃了