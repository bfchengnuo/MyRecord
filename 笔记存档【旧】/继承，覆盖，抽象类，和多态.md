# 继承，覆盖，抽象类，和多态

<br>

## 一、继承

1、继承的好处：让类与类之间产生了关系，提高了代码的复用型。

2、在java中继承的特点：

- java只支持单继承，不支持多继承。

	原因：会产生调用的不确定性。

- java支持多层继承，这样在java中就出现了继承体系。

3、如何快速的使用一个继承体系？

- 查阅父类内容，创建子类对象使用。

	注意：父类属性被私有化，子类即使继承也不能使用。

4、什么时候定义继承？

- 当事物之间存在所属关系的时候。

5、this关键字和super关键字

- This关键字：代表本类对象。

- Super关键字：代表父类所属的空间。

## 二、覆盖

1、什么是覆盖？


>当子类继承父类时，子类中有和父类中一模一样的方法时，子类的方法会覆盖父类的方法。

2、覆盖的使用注意事项。

- 2.1、当父类中的方法名和子类的方法名一样，返回值不一样时，会编译报错。

- 2.2、当父类的方法和子类的方法一摸一样时，会出现覆盖。自己有就别找别人。

- 2.3、子类覆盖父类时，必须保证覆盖方法比被覆盖方法权限大。

- 2.4、静态只能覆盖静态，或只能被静态覆盖。

3、什么时候使用覆盖？


>子类需要复写父类的功能，用到子类自己的功能时。<br>
>覆盖举例：描述旧手机和新手机的更新过程。

4、继承中子类的实例化过程。


>子类的所有构造函数中的第一行，默认有就是super()，用于调用父类的构造函数。也就是所子类在初始化的过程中父类也会初始化。
<br>结论：父类构造函数既可以给父类初始化，也可以给子类初始化。

5、为什么子类的构造函数都要去默认访问父类的构造函数呢？


>因为子类继承父类，可以访问父类中已有的一些属性。

6、继承的弊端

- 打破了函数的封装性，当子类的方法和父类一模一样时，会改写父类的内容。

	解决方法：用final修饰方法。

7、finale关键字的特点：

- 1、final是一个修饰符，既可以修饰类，又可以修饰方法，还可以修饰变量。

- 2、final修饰的类不可以被继承。当一个类中不想有子类的时候我们可以用final修饰。

- 3、final修饰的方法不可以被覆盖。

- 4、final修饰的变量是一个常量。

为了将固定的一些数据方便使用，给于一个容易阅读的名称。

一般为final修饰的变量名是用大写字母组成，如果有多个单词，用下划线隔开。

注意：

- 1、如果父类中手动定义了有参数的构造函数，那么子类的构造函数中必须得手动定义super      来访问父类的构造函数。

- 2、this和super调用构造函数只能定义构造函数的第一行，不能同时存在。

- 3、子父类中通常不会出同名的属性。

	父类中既然定义了num属性，子类其实就没有必要再定义属性了。

- 4、构造函数就是构造器。

## 三、抽象类 

当描述事物时，没有足够的信息对该事物进行描述，那么该描述对应的类就是抽象类。

       描述犬科，狼，狗。

抽象类的特点：

       1、抽象方法一定定义在抽象类中。

       2、抽象类和抽象方法必须用abstract关键字修饰。

       3、抽象类不可以被实例化。

       4、抽象类必须由其子类覆盖掉所有抽象方法后，其子类才能进行实例化。

细节问题：

       1、抽象类一定是个父类？

是

       2、抽象类是否有构造函数？

有，给子类提供初始化动作。

       3、抽象类中是否可以不定义抽象方法？

              
可以，作用是为了不让类实例化。

       4、抽象关键字不能和哪些关键字共存？
 final，private，static

       5、一般类和抽象类有什么异同呢?

相同之处：

- 里面可以定义属性，行为，构造函数。

不同之处：

- 一般类不可以定义抽象函数，抽象类可以。

- 一般类可以被实例化，抽象类不行。

- 一般类可以被继承，也可以不被继承。

- 抽象类一定要被继承，抽象方法由子类全部覆盖后才能实例化。

## 四、接口。

接口：当一个抽象类中全都是抽象方法的时候，这时可以讲这个抽象类定义成接口。

接口定义格式：

       定义接口跟定义类一样，不过是用interface来定义。

接口中常见定义内容：

       1、常量。全局变量吗，有固定修饰符 public static final

       2、抽象方法。固定修饰符 public abstract

       接口中不存在变量，变量通常要初始化，接口中不存在构造函数。

接口特点：

       1、接口用interface来定义。

       2、接口中的成员都有固定的修饰符。

       3、接口不能被实例化。

       4、几大口必须由其子类覆盖了所有的抽象方法，该子类才能实例化。

       5、接口中的成员都是public修饰的。

好处：

       接口可以被多实现，一个类可以实现多个接口。

       误区：抽象函数，也要遵从函数的基本定义格式，要明确结果，明确未知内容。只不过函数体由子类来完成。

       一个类在继承一个类的同时还可以实现多个接口。

       类与类之间是继承，而且是但继承。

       类与接口之间是实现，而且可以多实现。

       接口与接口之间是继承关系，而且可以多继承。

       调用情况？

接口的特点：

       接口是对外暴露的规则。

       接口的出现降低了耦合性。

       接口出现提高了扩展性。

              
示例：usb，硬盘

- 接口定义后：

	一方在使用这个接口，另一方在实现这个接口。

**接口和抽象类的区别：**

       1、类是用来继承的，只能单继承。

**接口是用来实现的，可以多实现。**

       2、类中可以定义非抽象内容，直接提供给子类使用。

**接口中只能定义抽象方法，需要子类全部实现。**

       3、类存在着继承关系，是is a关系。

接口的实现关系，是like a 关系。

接口使用的代码示例：

	abstract class 犬
	{
	
	       public viod eat(){}
	
	       public abstract void吼叫();
	
	}
	int interface 
	搜爆able
	
	{
	
	       abstract void搜爆();
	
	}
	
	class 搜爆犬 extends犬 implements
	搜爆able
	
	{
	
	       public void 
	吼叫(){}
	
	       public void 
	搜爆(){}
	
	}
	
	class 搜爆猫 extends猫 implements
	搜爆able
	
	{

	public void 
	搜爆(){}
	
	}
	
	 
	
	学生中有抽烟的学生，抽烟不是基本功能，而是扩展功能。
	
	class Student
	
	{
	
	       void study(){}
	
	}
	
	interface Somke
	
	{
	
	       void somking();
	
	}
	
	class SomkeStudent extends Student implements Somke
	
	{
	
	       public void somking(){}
	
	}

没有抽象方法的抽象类：

       当一个接口中有多个抽象方法时，我们只需要用到其中的一个方法。

       那么就写一个没有抽象方法的抽象类，来实现接口。

       没有抽象方法的抽象类，可以方便创建对象，去指定覆盖的方法。

## 四、多态。

多态性：在程序中的体现，父类或者接口的引用指向自己的子类对象。

       描述：动物，猫，狗，猪。

好处：提高了代码的扩展性。

弊端：只能使用父类中的功能，不能使用子类特有功能。（覆盖）

       示例：动物不具备抓老鼠功能。

多态前提：

       1、必须存在着继承关系。

       2、通常要有覆盖操作。

多态转型：注意：在转型过程中都是子类对象在做转换。

       1、向上转型。

       2、向下转型。（强制转型）。

              
好处：可以使用子类的特有功能。

              
弊端：如果类型转换错误，会出现运行异常。

**什么时候使用转型？**

       向上转型：当需要对程序进行扩展，或者限定对象的方法操作时。

       向下转型：当要使用子类特有内容时，转型时需要判断，否则容易出现问题。

多态类型判断：

       ClassCastException类型转换异常。

       向下转型前，要进行判断，否则容易发生异常。

       判断用instanceof来完成。

## 五、Object对象。在lang包中。

概述：

       Object：所有类的父类。

       所有对象都具备的内容不断抽取，就出现了Object类。

       Object对象存在的属性和方法，所有对象都存在。

Objcet中方法：

       1、equals(Object obj多态)比较两个对象是否相等。比较地址。源代码。

              
可以覆盖Object类中的equals方法建立自己的比较方法。需求：判断，只要是同龄人就是相同对象。

       2、toString()返回对象的字符串表示。（建议所有子类都重写此方法）

              
打印p ，p.toString。打印对象。

              
为了让自定义的对象对应的字符串表现形式有意义。

              
覆盖toString方法即可。    

       3、getClass():获取任意一个对象所属的字节码文件对象。为class类型的。

       4、hashCode():返回该对象的哈希码。

字节码文件类中方法：

              getName():打印出本类的类名。 native修饰符，调用本地。